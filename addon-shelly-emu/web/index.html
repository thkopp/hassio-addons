<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shelly Pro 3EM Emulator Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: sans-serif; padding: 1rem; background: #f0f0f5; }
  h1 { text-align: center; margin-bottom: 1rem; }

  .container { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center; }
  .box { background: #fff; padding: 1rem; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.15); flex: 1 1 250px; min-width: 250px; }
  .total { flex: 1 1 100%; margin-bottom: 1rem; }

  h2 { margin-top: 0; margin-bottom: 0.5rem; font-size: 1rem; }
  table { width: 100%; border-collapse: collapse; margin-bottom: 0.5rem; }
  th, td { padding: 0.3rem 0.5rem; text-align: left; font-size: 0.9rem; }
  td { display: flex; justify-content: space-between; align-items: center; }

  .bar-container { height: 12px; background: #ddd; border-radius: 6px; width: 70%; margin-right: 0.5rem; position: relative; }
  /* Doppelseitiger Balken mit Mittelachse */
  .bar-container.dual {position: relative; background: linear-gradient(to right, #ddd 50%, #ddd 50%);  overflow: visible;}
  .bar-container.dual::before {content: ""; position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background: #aaa; z-index: 1;}
  .bar-container.dual .bar {position: absolute;top: 0; height: 100%;transition: width 0.4s ease, left 0.4s ease, background 0.3s ease; z-index: 0;}

  .bar { height: 100%; border-radius: 6px; width: 0%; }
  canvas { width: 100%; height: 120px; }

  .value-container { display:flex; justify-content:flex-end; width:100%; }
  .right {text-align: right;}
  .section { margin-bottom: 0.5rem; display:flex; flex-direction:column; }
  .section-row { display:flex; align-items:center; justify-content: space-between; }

  .unit-container { display:flex; justify-content:flex-end; width:100%; }
  .left {text-align: left;}
  .section { margin-bottom: 0.5rem; display:flex; flex-direction:column; }
  .section-row { display:flex; align-items:center; justify-content: space-between; }
</style>
</head>
<body>

<h1>Shelly Pro 3EM Emulator</h1>

<style>
  .value-table {
    display: table;
    width: auto;
    margin-left: auto; /* rÃ¼ckt Tabelle nach rechts */
  }
  .value-row {
    display: table-row;
  }
  .value-cell {
    display: table-cell;
    padding-left: 0.25rem;
    text-align: right;
    font-weight: bold;
  }
  .unit-cell {
    display: table-cell;
    padding-left: 0.25rem;
    text-align: left;
    width: 2.5rem; /* sorgt fÃ¼r saubere Spalten */
    font-weight: bold;
  }

  .value-unit {
    display: flex;
    justify-content: flex-end;
    align-items: baseline;
    min-width: 70px;
    gap: 0.2rem;
  }
  .number {
    font-weight: bold;
    text-align: right;
  }
  .unit {
    font-weight: bold;
    text-align: left;
  }

  .label-cell {
    width: 160px;            /* Breite der Beschriftung */
    text-align: left;
    font-weight: bold;
    padding-right: 0.5rem;
    font-size: 0.9rem;
    white-space: nowrap;     /* kein Zeilenumbruch */
  }

  .section-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;              /* etwas Abstand zwischen Label, Balken, Wert */
  }

</style>




<div class="box total">

  <div class="section">
    <div class="section-row">
      <div class="label-cell">ZÃ¤hlerstand</div>
      <div class="bar-container"><div id="totalEnergyBar" class="bar"></div></div>
      <div class="value-table">
        <div class="value-row">
          <div id="totalEnergyVal" class="value-cell">0</div>
          <div class="unit-cell">kWh</div>
        </div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-row">
      <div class="label-cell">Netzbezug</div>
      <div class="bar-container"><div id="powerFromGridBar" class="bar"></div></div>
      <div class="value-table">
        <div class="value-row">
          <div id="powerFromGridVal" class="value-cell">0</div>
          <div class="unit-cell">W</div>
        </div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-row">
      <div class="label-cell">Netzeinspeisung</div>
      <div class="bar-container"><div id="powerToGridBar" class="bar"></div></div>
      <div class="value-table">
        <div class="value-row">
          <div id="powerToGridVal" class="value-cell">0</div>
          <div class="unit-cell">W</div>
        </div>
      </div>
    </div>
  </div>

<div class="section">
  <div class="section-row">
    <div class="label-cell">Gesamtleistung</div>
    <div class="bar-container dual">
      <div id="totalPowerBar" class="bar"></div>
    </div>
    <div class="value-table">
      <div class="value-row">
        <div id="totalPowerVal" class="value-cell">0</div>
        <div class="unit-cell">W</div>
      </div>
    </div>
  </div>
</div>

</div>

<div class="container" id="phases"></div>
<pre id="rpcOutput" style="
  background:#1e1e1e;
  color:#00ff88;
  padding:1rem;
  border-radius:8px;
  overflow:auto;
  max-height:300px;
  font-family: monospace;
  font-size: 0.8rem;
  box-shadow: inset 0 0 6px rgba(0,0,0,0.5);
  white-space: pre-wrap;    /* Zeilen umbrechen bei langen Texten */
"></pre>



<script>
let baseUrl = "";
const rpc_port = "8080";

const { protocol, hostname, pathname } = window.location;

if (pathname.includes("/api/hassio_ingress/")) {
  // ðŸŸ¢ Ingress-Modus
  const ingressId = pathname.split("/api/hassio_ingress/")[1].split("/")[0];
  baseUrl = `http://${hostname}:${rpc_port}`;
  console.log("Ingress detected â†’ baseUrl =", baseUrl);
}
else if (window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost") {
  // ðŸŸ  Lokaler Test (VS Code oder Browser)
  baseUrl = `http://127.0.0.1:${rpc_port}`;   // <-- hier: Backticks!
  console.log("Local dev mode, baseUrl =", baseUrl);
}
else {
  // ðŸ”µ Normaler LAN-/Host-Modus
  baseUrl = `${window.location.protocol}//${window.location.hostname}:${rpc_port}`;
  console.log("LAN mode, baseUrl =", baseUrl);
}

const maxDataPoints = 30;
const phasePowerCharts = [];
const phasePowerData = [[], [], []];
// const phasePhiData = [[], [], []];
const maxTotalPower = 15000;
const maxTotalEnergy = 100000;

function getColor(value, type = 'power') {
  if (type === 'power') {
    if (value < 1000) return 'green';
    if (value < 2000) return 'orange';
    return 'red';
  } else if (type === 'voltage') {
    if (value < 210) return 'red';
    if (value < 230) return 'orange';
    return 'green';
  } else if (type === 'current') {
    if (value < 5) return 'green';
    if (value < 15) return 'orange';
    return 'red';
  //else if (type === 'phi') {
    // if (Math.abs(value) < 30) return 'green';
    // if (Math.abs(value) < 90) return 'orange';
  //  return 'darkblue';
  }
  return 'gray';
}


function createPhaseDiv(idx) {
  const div = document.createElement('div');
  div.className = 'box';
  div.innerHTML = `
    <!-- <h2>L${idx + 1}</h2> -->
    <table>
      <tr><th>Leistung L${idx + 1}</th>
        <td>
          <div class="bar-container"><div id="barP${idx}" class="bar"></div></div>
          <div class="value-unit">
            <span class="number" id="p${idx}">0</span><span class="unit">W</span>
          </div>
        </td>
    </table>
    <canvas id="chart${idx}"></canvas>
  `;
  document.getElementById('phases').appendChild(div);

  const ctx = document.getElementById(`chart${idx}`).getContext('2d');
  const chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: Array(maxDataPoints).fill(''),
      datasets: [
        // {
        //   label: 'Ï†',
        //   data: Array(maxDataPoints).fill(0),
        //   borderColor: 'blue',
        //   backgroundColor: 'rgba(0,0,255,0.15)',
        //   yAxisID: 'yPhi',
        //   tension: 0.3,
        //   pointRadius: 0
        // },
        {
          label: 'P',
          data: Array(maxDataPoints).fill(0),
          //borderColor: 'green',
          //backgroundColor: 'rgba(0,255,0,0.15)',
          yAxisID: 'yPower',
          tension: 0.3,
          pointRadius: 0
        }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      plugins: {
        legend: { display: false, labels: { boxWidth: 12 }, position: 'bottom' }
      },
      scales: {
        // x: {
        //   ticks: {
        //     callback: (value, index) => (index % 5 === 0 ? `${index - maxDataPoints + 1}s` : '')
        //   }
        // },
        yPower: {
          type: 'linear',
          position: 'left',
          ticks: {
            callback: function(value) {
              return Math.round(value)+" W"; // nur ganze Zahlen
            }
          }
        }
        // ,
        // yPhi: {
        //   type: 'linear',
        //   position: 'left',
        //   ticks: {
        //     callback: function(value) {
        //       return Math.round(value)+" Â°"; // nur ganze Zahlen
        //     }
        //   }
        // }
      }
    }
  });

  phasePowerCharts.push(chart);
}

for (let i = 0; i < 3; i++) createPhaseDiv(i);

async function fetchStatus() {
  try {
    let rpcUrlGetStatus = `${baseUrl}/rpc/Shelly.GetStatus`;
    let rpcResGetStatus = await fetch(`${baseUrl}/rpc/Shelly.GetStatus`);
    if (!rpcResGetStatus.ok) throw new Error(`HTTP ${rpcResGetStatus.status}`);
    const dataGetStatus = await rpcResGetStatus.json();

    let combinedPower = 0;

    dataGetStatus.emeters.forEach((phase, idx) => {
      const v = Math.round(phase.voltage);
      const c = phase.current.toFixed(2);
      // const phi = Math.round(phase.phi);
      const p = Math.round(phase.power);
      combinedPower += p;

      document.getElementById(`p${idx}`).textContent = p;
      // document.getElementById(`v${idx}`).textContent = v;
      // document.getElementById(`c${idx}`).textContent = c;
      // document.getElementById(`phi${idx}`).textContent = phi;

      document.getElementById(`barP${idx}`).style.width = Math.min((p / 5000) * 100, 100) + '%';
      document.getElementById(`barP${idx}`).style.background = getColor(p, 'power');

      // document.getElementById(`barV${idx}`).style.width = Math.min((v / 250) * 100, 100) + '%';
      // document.getElementById(`barV${idx}`).style.background = getColor(v, 'voltage');

      // document.getElementById(`barC${idx}`).style.width = Math.min((c / 20) * 100, 100) + '%';
      // document.getElementById(`barC${idx}`).style.background = getColor(c, 'current');

      // document.getElementById(`barPhi${idx}`).style.width = (Math.abs(phi) / 180 * 100).toFixed(1) + '%';
      // document.getElementById(`barPhi${idx}`).style.background = getColor(phi, 'phi');

      // Verlauf aktualisieren
      phasePowerData[idx].push(p);
      // phasePhiData[idx].push(phi);
      if (phasePowerData[idx].length > maxDataPoints) phasePowerData[idx].shift();
      //if (phasePhiData[idx].length > maxDataPoints) phasePhiData[idx].shift();

      const powerColor = getColor(p, 'power');
      // const phiColor = getColor(phi, 'phi');
      const chart = phasePowerCharts[idx];

      chart.data.datasets[0].data = phasePowerData[idx];
      chart.data.datasets[0].borderColor = powerColor;
      chart.data.datasets[0].backgroundColor =
        `rgba(${powerColor === 'green' ? 0 : powerColor === 'orange' ? 255 : 255},
               ${powerColor === 'green' ? 255 : powerColor === 'orange' ? 165 : 0},0.15)`;

      // chart.data.datasets[1].data = phasePhiData[idx];
      // chart.data.datasets[1].borderColor = phiColor;
      // chart.data.datasets[1].backgroundColor = `rgba(0,0,255,0.15)`;

      chart.update('none');
    });

    const powerFromGrid = Math.round(dataGetStatus.power_from_grid);
    const powerToGrid = Math.round(dataGetStatus.power_to_grid);
    const totalPower = Math.round(dataGetStatus.total_power);
    const totalEnergy = Math.round(dataGetStatus.total_energy);

    document.getElementById('powerFromGridVal').textContent = powerFromGrid;
    document.getElementById('powerToGridVal').textContent = powerToGrid;
    document.getElementById('totalPowerVal').textContent = totalPower;
    document.getElementById('totalEnergyVal').textContent = totalEnergy;

    // === Korrekte Balken-IDs verwenden ===
    document.getElementById('powerFromGridBar').style.width =
      Math.min((powerFromGrid / maxTotalPower) * 100, 100) + '%';
    document.getElementById('powerFromGridBar').style.background = getColor(powerFromGrid, 'power');

    document.getElementById('powerToGridBar').style.width =
      Math.min((powerToGrid / maxTotalPower) * 100, 100) + '%';
    document.getElementById('powerToGridBar').style.background = getColor(powerToGrid, 'power');

    document.getElementById('totalEnergyBar').style.width =
      Math.min((totalEnergy / maxTotalEnergy) * 100, 100) + '%';
    document.getElementById('totalEnergyBar').style.background = 'green';

    // === Gesamtleistung mit negativer Anzeige ===
    const totalPowerBar = document.getElementById('totalPowerBar');
    const maxAbsPower = maxTotalPower;
    const powerRatio = Math.min(Math.abs(totalPower) / maxAbsPower, 1) * 50;

    if (totalPower >= 0) {
      totalPowerBar.style.left = '50%';
      totalPowerBar.style.width = powerRatio + '%';
      totalPowerBar.style.background = 'green';
    } else {
      totalPowerBar.style.left = (50 - powerRatio) + '%';
      totalPowerBar.style.width = powerRatio + '%';
      totalPowerBar.style.background = 'red';
    }

    let rpcUrlGetDeviceInfo = `${baseUrl}/rpc/Shelly.GetDeviceInfo`;
    let rpcResGetDeviceInfo = await fetch(rpcUrlGetDeviceInfo);
    if (!rpcResGetDeviceInfo.ok) throw new Error(`HTTP ${rpcResGetDeviceInfo.status}`);
    const dataGetDeviceInfo = await rpcResGetDeviceInfo.json();

    displayShellyRPCres = (
      rpcUrlGetDeviceInfo + ': \n' +
      JSON.stringify(dataGetDeviceInfo, null, 2) + '\n' + '\n' +
      rpcUrlGetStatus + ':\n' +
      JSON.stringify(dataGetStatus, null, 2)
    );

    document.getElementById('rpcOutput').textContent = displayShellyRPCres;

  } catch (err) {
    console.error("Error fetching status:", err);
  }
}

setInterval(fetchStatus, 3000);
fetchStatus();


</script>

</body>
</html>